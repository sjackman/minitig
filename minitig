#!/usr/bin/env python3
"""
Minitig: Assemble reads into contigs using minimizers
Written by Shaun Jackman @sjackman
"""

import argparse
import sys

from readfq import read_fasta

def kmerize(k, seq):
	"Iterator over the kmers of a string."
	for i in range(0, len(seq) - k + 1):
		yield seq[i : i + k]

def hash_int(key, mask=0xffffffffffffffff):
	"""
	Hash a 64-bit integer (invertible).
	See https://gist.github.com/lh3/59882d6b96166dfc3d8d
	"""
	assert 0 <= key < 0x10000000000000000
	key = (~key + (key << 21)) & mask # key = (key << 21) - key - 1
	key = key ^ key >> 24
	key = ((key + (key << 3)) + (key << 8)) & mask # key * 265
	key = key ^ key >> 14
	key = ((key + (key << 2)) + (key << 4)) & mask # key * 21
	key = key ^ key >> 28
	key = (key + (key << 31)) & mask
	assert 0 <= key < 0x10000000000000000
	return key

def unhash_int(key, mask=0xffffffffffffffff):
	"""
	Invert hash_int.
	https://gist.githubusercontent.com/lh3/974ced188be2f90422cc/raw/55fbbb63e489328fd9d1641897954ca997b65951/inthash.c
	"""
	assert 0 <= key < 0x10000000000000000

	# Invert key = key + (key << 31)
	tmp = (key - (key << 31))
	key = (key - (tmp << 31)) & mask

	# Invert key = key ^ (key >> 28)
	tmp = key ^ key >> 28
	key = key ^ tmp >> 28

	# Invert key *= 21
	key = (key * 14933078535860113213) & mask

	# Invert key = key ^ (key >> 14)
	tmp = key ^ key >> 14
	tmp = key ^ tmp >> 14
	tmp = key ^ tmp >> 14
	key = key ^ tmp >> 14

	# Invert key *= 265
	key = (key * 15244667743933553977) & mask

	# Invert key = key ^ (key >> 24)
	tmp = key ^ key >> 24
	key = key ^ tmp >> 24

	# Invert key = (~key) + (key << 21)
	tmp = ~key
	tmp = ~(key - (tmp << 21))
	tmp = ~(key - (tmp << 21))
	key = ~(key - (tmp << 21)) & mask

	assert 0 <= key < 0x10000000000000000
	return key

# Translate the ACGT to ASCII 0-3.
TRANSLATE_ACGT_0123 = str.maketrans("ACGT", "\0\1\2\3")

# Translate the ASCII 0-3 to ACGT.
TRANSLATE_0123_ACGT = str.maketrans("\0\1\2\3", "ACGT")

def kmer_to_int(kmer):
	"Convert a k-mer to an integer."
	x = 0
	for c in kmer.translate(TRANSLATE_ACGT_0123):
		assert 0 <= ord(c) < 4
		x <<= 2
		x += ord(c)
	return x

def int_to_kmer(x, k):
	"Convert an integer to a k-mer."
	assert x >= 0
	xs = k * [None]
	for i in reversed(range(k)):
		xs[i] = chr(x & 3)
		x >>= 2
	assert x == 0
	return str.join("", xs).translate(TRANSLATE_0123_ACGT)

def hash_kmer(kmer):
	"Hash a k-mer to an integer."
	return hash_int(kmer_to_int(kmer))

def unhash_kmer(x, k):
	"Unhash an integer to a k-mer."
	return int_to_kmer(unhash_int(x), k)

def minimerize(k, w, seq):
	"Return the minimizers of a string."
	hashes = [hash_kmer(kmer) for kmer in kmerize(k, seq)]
	minimizers = []
	previous_minimizer = -1
	for i in range(0, len(hashes) - w + 1):
		minimizer, minimizer_i = min((x, i) for (i, x) in enumerate(hashes[i : i + w]))
		minimizer_i += i
		if minimizer_i > previous_minimizer:
			previous_minimizer = minimizer_i
			minimizers.append(minimizer)
	return minimizers

def minitig_index():
	"Index a set of sequences"
	for filename in ARGS.FASTA:
		with open(filename) as fin:
			for _, seq in read_fasta(fin):
				seq = seq.upper()
				print(minimerize(ARGS.k, ARGS.w, seq))

def minitig_map():
	"Map sequences"
	print("strict digraph {")
	for filename in ARGS.FASTA:
		with open(filename) as fin:
			for name, seq in read_fasta(fin):
				seq = seq.upper()
				print("//", name)
				minimizers = minimerize(ARGS.k, ARGS.w, seq)
				for u, v in zip(minimizers, minimizers[1:]):
					print(unhash_kmer(u, ARGS.k), "->", unhash_kmer(v, ARGS.k))
	print("}")

def parse_arguments():
	"Parse the command line arguments."
	argparser = argparse.ArgumentParser()
	argparser.add_argument(
		"-k", "--k", action="store", type=int, required=True,
		help="size of a k-mer (bp)")
	argparser.add_argument(
		"-w", "--window", action="store", dest="w", type=int, required=True,
		help="number of k-mers in a window of size k + w - 1 bp")
	argparser.add_argument(
		"command",
		help="One of the commands: index or map")
	argparser.add_argument(
		"FASTA", nargs="+",
		help="FASTA file of sequences to be assembled")
	return argparser.parse_args()

def main():
	"Process each file specified on the command line"
	ARGS.FASTA = ["/dev/stdin" if s == "-" else s for s in ARGS.FASTA]
	if ARGS.command == "index":
		minitig_index()
	elif ARGS.command == "map":
		minitig_map()
	else:
		print("Unrecognized command: ", ARGS.command, file=sys.stderr)
		exit(1)

if __name__ == "__main__":
	ARGS = parse_arguments()
	main()
